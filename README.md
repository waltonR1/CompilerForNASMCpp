# Simplified Compiler (Flex / Bison / IR / NASM)

This project implements a **simplified but complete compiler**. The compiler takes a C-like pseudocode program as input and follows a standard compilation pipeline, including lexical analysis, syntax analysis, abstract syntax tree (AST) construction, intermediate representation (IR) generation and optimization, and finally **NASM assembly code generation**. The generated assembly code can be assembled and linked into an executable program, which is the final output of this project.

The goal of this project is not to build an industrial-strength programming language, but to provide a fully working end-to-end compiler pipeline in order to better understand compiler architecture, control-flow translation, and basic code optimization techniques.

---

## Features

* Lexical analysis implemented with **Flex**
* Syntax analysis implemented with **Bison**, including operator precedence handling
* Construction and traversal of an abstract syntax tree (AST)
* Generation of a three-address-code-style intermediate representation (IR)
* Several IR-level optimizations (constant folding, unreachable code elimination, etc.)
* Translation from IR to **NASM assembly code (final artifact)**
* The generated assembly code can be assembled and executed successfully

---

## Project Structure

```text
Task04_BisonParser_IR/
├── .github/
│   └── workflows/
│       └── ci.yml
├── include/
│   ├── ast.hpp        # AST node definitions
│   ├── codegen.hpp    # Assembly code generation declarations
│   ├── ir.hpp         # Intermediate representation (IR) definitions
│   └── tokens.hpp     # Token definitions for Flex / Bison
├── src/
│   ├── codegen.cpp    # IR → NASM assembly generation
│   ├── ir.cpp         # IR generation and optimization
│   └── main.cpp       # Compiler entry point
├── parser.yy          # Bison grammar file
├── scanner.l          # Flex lexer rules
├── CMakeLists.txt     # CMake build configuration
├── read.txt           # Example input program
├── expected.txt       # Reference output
├── .gitignore
├── output.asm         # Generated NASM assembly code (artifact)
├── output.o           # Assembled object file (artifact)
└── program            # Final executable (artifact)
```

> Note: `cmake-build-debug/` is a local build directory generated by the IDE and is not part of the source tree.

---

## Compilation Pipeline

The compilation process consists of the following stages:

1. **Lexical Analysis**
   Flex is used to convert the source code character stream into a stream of tokens. The lexer supports identifiers, keywords, integer and string literals, operators, and multiple comment styles.

2. **Syntax Analysis**
   Bison analyzes the token stream according to the grammar rules and builds the abstract syntax tree (AST) using semantic actions. Operator precedence and associativity are handled using Bison declarations.

3. **AST Construction and Validation**
   The AST represents the hierarchical structure of the program. A depth-first traversal (DFS) is used to print and inspect the AST to verify its correctness. Special AST nodes are introduced to correctly handle string assignments and string concatenation.

4. **IR Generation and Optimization**
   The AST is translated into a linear sequence of IR instructions using a three-address code style. The IR includes assignments, comparisons, conditional jumps, unconditional jumps, labels, and print operations. Several simple optimizations are applied, including:

    * Constant folding
    * Compile-time evaluation of constant conditions
    * Unreachable code elimination
    * Temporary variable elimination
    * Dead assignment elimination
    * Removal of redundant jumps and unused labels

5. **Assembly Code Generation**
   The optimized IR is translated into NASM assembly code, producing a `.asm` file. The generated assembly includes data, BSS, and text sections, as well as helper routines for printing integers and strings when needed. This assembly file can be assembled and linked into a runnable executable, which is the final output of the compiler.

---

## Build and Run

### Build the Project

```bash
mkdir build
cd build
cmake ..
make
```

### Run the Compiler

```bash
./compiler read.txt
```

### Assemble and Execute the Output Program

```bash
nasm -f elf64 output.asm -o output.o
gcc output.o -o program
./program
```