%option noyywrap nodefault nounput yylineno

%{
#include <string>
#include <vector>
#include <stdexcept>
#include "tokens.hpp" // Still needed for Token struct and TokenType
#include "parser.tab.hpp" // Generated by Bison for token ids and YYSTYPE

/* Declare yylval - defined in parser.tab.cpp */
extern YYSTYPE yylval;

/* * 1. INCLUDE BISON HEADER
 * This file (parser.tab.hpp) is generated by Bison and contains
 * all the token definitions (e.g., T_IF, T_INTLIT) and the
 * 'YYSTYPE' union definition (which we aliased to yylval).
 */

/*
 * 2. KEEP SCANNER API FOR MAIN.CPP
 * These function prototypes are still needed by main.cpp
 * to set up the input buffer.
 */
typedef struct yy_buffer_state *YY_BUFFER_STATE;
int yylex(void);
void yyrestart(FILE*);
YY_BUFFER_STATE yy_scan_string(const char* str);
void yy_delete_buffer(YY_BUFFER_STATE b);

/* * We no longer need g_tokens, g_buf, scan_to_tokens, 
 * or scan_string_to_tokens. Bison calls yylex() directly.
 */

%}

/* Regex definitions remain the same */
DIGIT      [0-9]
ID_START   [A-Za-z_]
ID_CONT    [A-Za-z0-9_]
WS         [ \t\r\f]+
NL         [\n]

%%

"//".*                          ;   /* C++ single-line comment */
"#".*                           ;   /* shell-style comment */
"/*"([^*]|\*+[^*/])*\*+"/"      ;   /* C-style block comment */


\"([^\"\\]|\\.)*\"       {
    std::string s(yytext + 1, yyleng - 2);
    /* Store the Token struct in yylval (in the 'token' field) */
    yylval.token = Token{TokenType::String, s, yylineno};
    /* Return the token ID defined in Bison */
    return T_STRING;
}


"=="|">="|"<="|"!="      {
    yylval.token = Token{TokenType::Comparison,
                              std::string(yytext, yyleng), yylineno};
    return T_COMPARISON;
}


"+"                      { return '+'; }
"-"                      { return '-'; }
"*"                      { return '*'; }
"/"                      { return '/'; }
"="                      { return T_ASSIGN; } // Or just return '='
"("                      { return T_LPAREN; } // Or just return '('
")"                      { return T_RPAREN; } // Or just return ')'
"{"                      { return T_LBRACE; } // Or just return '{'
"}"                      { return T_RBRACE; } // Or just return '}'
";"                      { return T_SEMICOLON; } // Or just return ';'
","                      { return ','; }


"<"|">"                  {
    yylval.token = Token{TokenType::Comparison,
                              std::string(yytext, yyleng), yylineno};
    return T_COMPARISON;
}


{ID_START}{ID_CONT}* {
    std::string s(yytext, yyleng);
    
    /* Return simple keyword token IDs */
    if      (s == "if")     return T_IF;
    else if (s == "else")   return T_ELSE;
    else if (s == "while")  return T_WHILE;
    else if (s == "int")    return T_INT;
    else if (s == "print")  return T_PRINT;
    else if (s == "prints") return T_PRINTS;
    else if (s == "string") return T_STRINGKW;
    else {
        /* It's a variable. Pass the Token struct via yylval. */
        yylval.token = Token{TokenType::Var, "V" + s, yylineno};
        return T_VAR;
    }
}

{DIGIT}+                 {
    /* It's an integer literal. Pass the Token struct via yylval. */
    yylval.token = Token{TokenType::IntLit,
                              std::string(yytext, yyleng), yylineno};
    return T_INTLIT;
}

{WS}                     ; /* Ignore whitespace */
{NL}                     ; /* Ignore newlines */

.                        {
    throw std::runtime_error("Unknown char at line " +
                             std::to_string(yylineno));
}

<<EOF>>                  {
    /* Signal End-of-File to Bison - return 0 to indicate no more tokens */
    return 0;
}

%%
